"""Map between agent prompt components and GEPA candidates."""

from __future__ import annotations

from collections.abc import Iterator, Sequence
from contextlib import ExitStack, contextmanager
from typing import TYPE_CHECKING, Any, Literal, TypeVar

from pydantic import BaseModel, Field
from pydantic.fields import FieldInfo
from pydantic_ai.agent.wrapper import WrapperAgent

from .signature import InputSpec, build_input_spec
from .signature_agent import SignatureAgent
from .tool_components import get_tool_optimizer

if TYPE_CHECKING:
    from pydantic_ai.agent import AbstractAgent


def _strip_surrogate_characters(text: str) -> str:
    """Remove stray UTF-16 surrogate code points to keep text JSON-safe.

    Args:
        text: Raw text that may include half-surrogates generated by providers.

    Returns:
        The same text with surrogate code points removed.

    Examples:
        >>> _strip_surrogate_characters("Valid\\ud800")
        'Valid'
    """
    # Filter out lone surrogate characters that cause UTF-8 encoding failures.
    return "".join(char for char in text if not 0xD800 <= ord(char) <= 0xDFFF)


def normalize_component_text(value: Any) -> str:
    """Normalize prompt component values to safe string representations.

    Args:
        value: A prompt component value (string, list, tuple, etc.).

    Returns:
        A UTF-8-safe string suitable for GEPA serialization.

    Examples:
        >>> normalize_component_text(["Step 1", "Step 2"])
        'Step 1\\n\\nStep 2'
    """
    if value is None:
        return ""
    if isinstance(value, str):
        return _strip_surrogate_characters(value)
    if isinstance(value, Sequence) and not isinstance(value, (str, bytes)):
        # Join multi-part components with blank lines to preserve readability.
        joined = "\n\n".join(str(part) for part in value if part)
        return _strip_surrogate_characters(joined)
    # Fallback to string conversion, then sanitize surrogate code points.
    return _strip_surrogate_characters(str(value))


def extract_seed_candidate(agent: AbstractAgent[Any, Any]) -> dict[str, str]:
    """Extract the current prompts from an agent as a GEPA candidate.

    Args:
        agent: The agent to extract prompts from.

    Returns:
        A dictionary mapping component names to their text values.
        - 'instructions': The effective instructions (combining literal and functions)
    """
    candidate: dict[str, str] = {}

    target_agent = agent
    if isinstance(agent, WrapperAgent):
        target_agent = agent.wrapped

    # Extract instructions
    # Note: In v1, we extract the literal instructions only, not the dynamic ones
    # The dynamic instructions from functions will be disabled during optimization
    if hasattr(target_agent, "_instructions") and target_agent._instructions:  # type: ignore[attr-defined]
        candidate["instructions"] = normalize_component_text(
            target_agent._instructions  # type: ignore[attr-defined]
        )
    else:
        candidate["instructions"] = ""

    if isinstance(agent, SignatureAgent):
        if agent.optimize_tools:
            candidate.update(agent.get_tool_components())
    else:
        optimizer = get_tool_optimizer(agent)
        if optimizer:
            candidate.update(optimizer.get_seed_components())

    return candidate


@contextmanager
def apply_candidate_to_agent(
    agent: AbstractAgent[Any, Any],
    candidate: dict[str, str] | None,
) -> Iterator[None]:
    """Apply a GEPA candidate to an agent via override().

    This returns a context manager that temporarily applies the candidate
    prompts to the agent.

    Args:
        agent: The agent to apply prompts to.
        candidate: The candidate mapping component names to text.

    Returns:
        A context manager for the temporary override.
    """
    instructions_raw = candidate.get("instructions") if candidate else None
    instructions = (
        normalize_component_text(instructions_raw) if instructions_raw else None
    )

    target_agent = agent
    if isinstance(agent, WrapperAgent):
        target_agent = agent.wrapped

    optimizer = get_tool_optimizer(agent)

    with ExitStack() as stack:
        if optimizer:
            stack.enter_context(optimizer.candidate_context(candidate))
        if instructions:
            stack.enter_context(target_agent.override(instructions=instructions))
        yield


def get_component_names(agent: AbstractAgent[Any, Any]) -> list[str]:
    """Get the list of optimizable component names for an agent.

    Args:
        agent: The agent to inspect.

    Returns:
        List of component names that can be optimized.
    """
    components: list[str] = ["instructions"]

    optimizer = get_tool_optimizer(agent)
    if isinstance(agent, SignatureAgent) and not agent.optimize_tools:
        optimizer = None

    if optimizer:
        components.extend(optimizer.get_component_keys())

    # Preserve order but ensure uniqueness
    seen: set[str] = set()
    deduped: list[str] = []
    for component in components:
        if component not in seen:
            deduped.append(component)
            seen.add(component)

    return deduped


def validate_components(
    agent: AbstractAgent[Any, Any], components: Sequence[str]
) -> list[str]:
    """Validate that the requested components exist in the agent.

    Args:
        agent: The agent to check against.
        components: The requested component names.

    Returns:
        The validated list of component names.

    Raises:
        ValueError: If any component doesn't exist in the agent.
    """
    available = set(get_component_names(agent))
    requested = set(components)

    invalid = requested - available
    if invalid:
        raise ValueError(
            f"Components {invalid} not found in agent. Available components: {sorted(available)}"
        )

    return list(components)


def extract_seed_candidate_with_signature(
    agent: AbstractAgent[Any, Any],
    input_type: InputSpec[BaseModel] | None = None,
) -> dict[str, str]:
    """Extract initial prompts from an agent and optionally a signature as a GEPA candidate.

    Args:
        agent: The agent to extract prompts from.
        input_type: Optional structured input specification to extract from.

    Returns:
        Combined dictionary of all components and their initial text.
    """
    candidate: dict[str, str] = {}

    # Extract from agent
    candidate.update(extract_seed_candidate(agent))

    # Extract from signature if provided
    if input_type:
        spec = build_input_spec(input_type)
        candidate.update(spec.get_gepa_components())

    return candidate


@contextmanager
def apply_candidate_to_agent_and_signature(
    candidate: dict[str, str] | None,
    agent: AbstractAgent[Any, Any],
    input_type: InputSpec[BaseModel] | None = None,
) -> Iterator[None]:
    """Apply a GEPA candidate to an agent and optionally a signature.

    This context manager temporarily applies the candidate to the agent
    (via override()) and optionally to a signature class.

    Args:
        candidate: The candidate mapping component names to text.
        agent: The agent to apply prompts to.
        input_type: Optional structured input specification to apply to.

    Yields:
        None while the candidate is applied.
    """
    from contextlib import ExitStack

    with ExitStack() as stack:
        # Apply to agent
        stack.enter_context(apply_candidate_to_agent(agent, candidate))

        # Apply to signature if provided
        if input_type:
            spec = build_input_spec(input_type)
            stack.enter_context(spec.apply_candidate(candidate))

        yield

ModelT = TypeVar("ModelT", bound=BaseModel)


def create_model_from_candidate(
    model_cls: type[ModelT],
    candidate: dict[str, str],
    *,
    model_type: Literal["signature", "tool"] = "signature",
    tool_name: str | None = None,
) -> type[ModelT]:
    """Create a new Pydantic model with descriptions updated from a candidate dictionary.
    
    This function creates a new model class with updated docstring and field descriptions
    based on the optimization candidate. It handles both signature-type models (input models)
    and tool-type models (output/result models).
    
    Args:
        model_cls: The original Pydantic BaseModel class to update.
        candidate: Dictionary mapping component keys to optimized text values.
            For signature models, keys are:
                - "signature:{ModelName}:instructions" -> model.__doc__
                - "signature:{ModelName}:{field_name}:desc" -> Field description
            For tool models, keys are:
                - "tool:{tool_name}:description" -> model.__doc__
                - "tool:{tool_name}:param:{field_name}" -> Field description
        model_type: Type of model - either "signature" or "tool" (default: "signature").
        tool_name: For tool models, the name of the tool (often "final_result"). 
            If None, uses the model class name. Required when the tool name differs
            from the model class name.
    
    Returns:
        A new model class with updated descriptions. The new class inherits from the
        original and has the same name, but with modified __doc__ and field descriptions.
    
    Example:
        >>> from pydantic import BaseModel, Field
        >>> 
        >>> # Signature model example
        >>> class EmailInput(BaseModel):
        ...     '''Analyze email sentiment'''
        ...     email_text: str = Field(description="The email content")
        ...
        >>> candidate = {
        ...     "signature:EmailInput:instructions": "Analyze facility support emails",
        ...     "signature:EmailInput:email_text:desc": "Complete email text"
        ... }
        >>> UpdatedInput = create_model_from_candidate(
        ...     EmailInput, candidate, model_type="signature"
        ... )
        >>> 
        >>> # Tool model example (note: tool_name is "final_result")
        >>> class EmailClassification(BaseModel):
        ...     '''Classify emails'''
        ...     urgency: str = Field(description="Urgency level")
        ...
        >>> candidate = {
        ...     "tool:final_result:description": "Comprehensive email analysis",
        ...     "tool:final_result:param:urgency": "Urgency: high, medium, or low"
        ... }
        >>> UpdatedOutput = create_model_from_candidate(
        ...     EmailClassification, candidate, model_type="tool", tool_name="final_result"
        ... )
    """
    if not issubclass(model_cls, BaseModel):
        raise TypeError(f"model_cls must be a Pydantic BaseModel subclass, got {type(model_cls)}")
    
    if model_type not in ("signature", "tool"):
        raise ValueError(f"model_type must be 'signature' or 'tool', got {model_type!r}")
    
    model_name = model_cls.__name__
    
    # For tool models, use the tool_name if provided, otherwise use model class name
    lookup_name = tool_name if (model_type == "tool" and tool_name) else model_name
    
    # Determine the key prefix based on model type
    if model_type == "signature":
        instructions_key = f"signature:{lookup_name}:instructions"
        field_key_template = f"signature:{lookup_name}:{{field_name}}:desc"
    else:  # tool
        instructions_key = f"tool:{lookup_name}:description"
        field_key_template = f"tool:{lookup_name}:param:{{field_name}}"
    
    # Get updated docstring if available
    updated_doc = candidate.get(instructions_key, model_cls.__doc__)
    
    # Create new field definitions with updated descriptions
    new_fields: dict[str, tuple[Any, FieldInfo]] = {}
    
    for field_name, field_info in model_cls.model_fields.items():
        # Get the field key for this specific field
        field_key = field_key_template.format(field_name=field_name)
        
        # Check if there's an updated description in the candidate
        updated_description = candidate.get(field_key)
        
        if updated_description is not None:
            # Create a new FieldInfo with the updated description
            # Preserve all other field properties
            new_field_info = Field(
                default=field_info.default,
                default_factory=field_info.default_factory,
                alias=field_info.alias,
                title=field_info.title,
                description=updated_description,  # Updated description
                exclude=field_info.exclude,
                frozen=field_info.frozen,
                validate_default=field_info.validate_default,
                repr=field_info.repr,
                init=field_info.init,
                init_var=field_info.init_var,
                kw_only=field_info.kw_only,
                json_schema_extra=field_info.metadata,
            )
            new_fields[field_name] = (field_info.annotation, new_field_info)
        else:
            # Keep the original field as-is
            new_fields[field_name] = (field_info.annotation, field_info)
    
    # Create a new model class with the updated fields and docstring
    from pydantic import create_model
    
    NewModel = create_model(
        model_name,
        __base__=model_cls,
        __doc__=updated_doc,
        **new_fields,  # type: ignore[arg-type]
    )
    
    return NewModel  # type: ignore[return-value]


def apply_candidate_to_signature_model(
    model_cls: type[ModelT],
    candidate: dict[str, str],
) -> type[ModelT]:
    """Create a new signature model with descriptions updated from a candidate.
    
    This is a convenience wrapper around create_model_from_candidate for signature-type
    models (input models). It updates the model's __doc__ (instructions) and field
    descriptions based on keys in the candidate dictionary.
    
    Args:
        model_cls: The original signature model class.
        candidate: Dictionary with keys like:
            - "signature:{ModelName}:instructions"
            - "signature:{ModelName}:{field_name}:desc"
    
    Returns:
        A new model class with updated descriptions.

    """
    return create_model_from_candidate(model_cls, candidate, model_type="signature")


def apply_candidate_to_tool_model(
    model_cls: type[ModelT],
    candidate: dict[str, str],
    *,
    tool_name: str = "final_result",
) -> type[ModelT]:
    """Create a new tool model with descriptions updated from a candidate.
    
    This is a convenience wrapper around create_model_from_candidate for tool-type
    models (output/result models). It updates the model's __doc__ (tool description)
    and field descriptions based on keys in the candidate dictionary.
    
    Args:
        model_cls: The original tool/output model class.
        candidate: Dictionary with keys like:
            - "tool:{tool_name}:description"
            - "tool:{tool_name}:param:{field_name}"
        tool_name: The name of the tool used during optimization (default: "final_result").
            This is typically "final_result" for the main output type of an agent.
    
    Returns:
        A new model class with updated descriptions.
    """
    return create_model_from_candidate(
        model_cls, candidate, model_type="tool", tool_name=tool_name
    )